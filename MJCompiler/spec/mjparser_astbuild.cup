

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, ASSIGN, RETURN, PLUS, COMMA, PRINT, VOID;
terminal Integer NUMBER;
terminal String IDENT;
terminal Boolean BOOL;
terminal Character CHARCONST;

terminal COLON, FOR, STATIC, EXTENDS, NEW, GTE, ELSE, IF;
terminal  DOT, DIV, MINUS, CONST, AND, LESS, LSQUARE, RSQUARE;
terminal MOD, MUL, BREAK, EQUALS, INCREMENT, DECREMENT, LEQ, GREATER, NAMESPACE;
terminal CLASS, NOTEQUALS, CONTINUE, OR;

nonterminal Program Program;
nonterminal DeclarationList DeclarationList;
nonterminal Namespace Namespace;
nonterminal MethodDeclarationList MethodDeclarationList;
nonterminal ConstDecl ConstDecl;
nonterminal VarDecl VarDecl;
nonterminal ClassDecl ClassDecl;
nonterminal SingleConst SingleConst;
nonterminal ConstList ConstList;
nonterminal Type Type;
nonterminal SingleVar SingleVar;
nonterminal VarList VarList;
nonterminal MaybeArray MaybeArray;
nonterminal MethodDecl MethodDecl;
nonterminal SingleMethodDecl SingleMethodDecl;
nonterminal ReturnType ReturnType;
nonterminal LocalVarDecl LocalVarDecl;
nonterminal MaybeFormPars MaybeFormPars;
nonterminal FormPars FormPars;
nonterminal SinglePar SinglePar;



Program ::= (Program) PROG IDENT:I1 DeclarationList:D2 LBRACE MethodDecl:M3 RBRACE {: RESULT=new Program(I1, D2, M3); RESULT.setLine(I1left); :};

Type ::= IDENT:I1 {: RESULT=new TypeDerived1(I1); RESULT.setLine(I1left); :};

DeclarationList ::=(GlobalConstants)	DeclarationList:D1 ConstDecl:C2 {: RESULT=new GlobalConstants(D1, C2); RESULT.setLine(D1left); :} 
				|
				(GlobalVars) DeclarationList:D1 VarDecl:V2 {: RESULT=new GlobalVars(D1, V2); RESULT.setLine(D1left); :}
				|
				(NoGlobals) {: RESULT=new NoGlobals(); :}/*empty*/;

/* ConstDeclaration */
ConstDecl ::=(Constants) CONST Type:T1 SingleConst:S2 ConstList:C3 SEMI {: RESULT=new Constants(T1, S2, C3); RESULT.setLine(T1left); :};

ConstList ::= (ConstantList) ConstList:C1 COMMA SingleConst:S2 {: RESULT=new ConstantList(C1, S2); RESULT.setLine(C1left); :}
			| (NoConsts) {: RESULT=new NoConsts(); :} /* empty */;

SingleConst ::= (IntConst) IDENT:I1 ASSIGN NUMBER:N2 {: RESULT=new IntConst(I1, N2); RESULT.setLine(I1left); :} | (BoolConst )IDENT:I1 ASSIGN BOOL:B2 {: RESULT=new BoolConst(I1, B2); RESULT.setLine(I1left); :} | (CharConst )IDENT:I1 ASSIGN CHARCONST:C2 {: RESULT=new CharConst(I1, C2); RESULT.setLine(I1left); :};

/* VarDeclatation*/
VarDecl ::= (Variables) Type:T1 SingleVar:S2 VarList:V3 SEMI {: RESULT=new Variables(T1, S2, V3); RESULT.setLine(T1left); :};
		
SingleVar ::= (SingleVar) IDENT:I1 MaybeArray:M2 {: RESULT=new SingleVar(I1, M2); RESULT.setLine(I1left); :};

VarList ::= (VariableList) VarList:V1 COMMA SingleVar:S2 {: RESULT=new VariableList(V1, S2); RESULT.setLine(V1left); :}
		|(NoVars) {: RESULT=new NoVars(); :}	/*empty*/;
		
MaybeArray ::= (Array) LSQUARE RSQUARE {: RESULT=new Array(); :}
			|(NotArray) {: RESULT=new NotArray(); :} /*empty*/	;
		
/*MethodDecl*/
MethodDecl ::= (Methods) MethodDecl:M1 SingleMethodDecl:S2 {: RESULT=new Methods(M1, S2); RESULT.setLine(M1left); :} 
			| (NoMethod) {: RESULT=new NoMethod(); :} /*empty*/;
SingleMethodDecl ::= (SingleMethodDecl) ReturnType:R1 IDENT:I2 LPAREN MaybeFormPars:M3 RPAREN LocalVarDecl:L4 LBRACE RBRACE {: RESULT=new SingleMethodDecl(R1, I2, M3, L4); RESULT.setLine(R1left); :};

LocalVarDecl ::= (LocalVars1) VarDecl:V1 {: RESULT=new LocalVars1(V1); RESULT.setLine(V1left); :} | (NoLocalVars) {: RESULT=new NoLocalVars(); :} /*empty*/;

ReturnType ::= (ReturnVoid) VOID {: RESULT=new ReturnVoid(); :} | (ReturnSmt) Type:T1 {: RESULT=new ReturnSmt(T1); RESULT.setLine(T1left); :};

/*FormPars*/
MaybeFormPars ::= (Parameters) FormPars:F1 {: RESULT=new Parameters(F1); RESULT.setLine(F1left); :} | (NoPars) {: RESULT=new NoPars(); :} /*empty*/;

FormPars ::= (MultiplePars) FormPars:F1 COMMA SinglePar:S2 {: RESULT=new MultiplePars(F1, S2); RESULT.setLine(F1left); :}
			|(OnePar) SinglePar:S1 {: RESULT=new OnePar(S1); RESULT.setLine(S1left); :};
			
SinglePar ::= Type:T1 IDENT:I2 MaybeArray:M3 {: RESULT=new SingleParDerived1(T1, I2, M3); RESULT.setLine(T1left); :};


